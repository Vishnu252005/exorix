'use client';
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
import { RequestContext } from '../../core/network/constants.js';
import { useLifecycleStatus } from '../../internal/hooks/useLifecycleStatus.js';
import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { base } from 'viem/chains';
import { useAccount, useSwitchChain, useConfig, useSendTransaction } from 'wagmi';
import { useSendCalls } from 'wagmi/experimental';
import { buildSwapTransaction } from '../../api/buildSwapTransaction.js';
import { useAnalytics } from '../../core/analytics/hooks/useAnalytics.js';
import { BuyEvent } from '../../core/analytics/types.js';
import { useCapabilitiesSafe } from '../../internal/hooks/useCapabilitiesSafe.js';
import { useValue } from '../../internal/hooks/useValue.js';
import { FALLBACK_DEFAULT_MAX_SLIPPAGE } from '../../swap/constants.js';
import { useAwaitCalls } from '../../swap/hooks/useAwaitCalls.js';
import { isSwapError } from '../../swap/utils/isSwapError.js';
import { processSwapTransaction } from '../../swap/utils/processSwapTransaction.js';
import { GENERIC_ERROR_MESSAGE } from '../../transaction/constants.js';
import { isUserRejectedRequestError } from '../../transaction/utils/isUserRejectedRequestError.js';
import { useOnchainKit } from '../../useOnchainKit.js';
import { useBuyTokens } from '../hooks/useBuyTokens.js';
import { useOnrampEventListeners } from '../hooks/useOnrampEventListeners.js';
import { usePopupMonitor } from '../hooks/usePopupMonitor.js';
import { useResetBuyInputs } from '../hooks/useResetBuyInputs.js';
import { getBuyQuote } from '../utils/getBuyQuote.js';
import { validateQuote } from '../utils/validateQuote.js';
import { jsx } from 'react/jsx-runtime';
const emptyContext = {};
const BuyContext = /*#__PURE__*/createContext(emptyContext);
function useBuyContext() {
  const context = useContext(BuyContext);
  if (context === emptyContext) {
    throw new Error('useBuyContext must be used within a Buy component');
  }
  return context;
}
function BuyProvider({
  children,
  config = {
    maxSlippage: FALLBACK_DEFAULT_MAX_SLIPPAGE
  },
  disabled,
  experimental,
  isSponsored,
  onError,
  onStatus,
  onSuccess,
  toToken,
  fromToken
}) {
  const _useOnchainKit = useOnchainKit(),
    _useOnchainKit$config = _useOnchainKit.config,
    _useOnchainKit$config2 = _useOnchainKit$config === void 0 ? {
      paymaster: undefined
    } : _useOnchainKit$config,
    paymaster = _useOnchainKit$config2.paymaster,
    projectId = _useOnchainKit.projectId;
  const _useAccount = useAccount(),
    address = _useAccount.address,
    chainId = _useAccount.chainId;
  const _useSwitchChain = useSwitchChain(),
    switchChainAsync = _useSwitchChain.switchChainAsync;
  // Feature flags
  const useAggregator = experimental.useAggregator;
  // Core Hooks
  const accountConfig = useConfig();
  const _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isDropdownOpen = _useState2[0],
    setIsDropdownOpen = _useState2[1];
  const walletCapabilities = useCapabilitiesSafe({
    chainId: base.id
  }); // Swap is only available on Base
  const _useLifecycleStatus = useLifecycleStatus({
      statusName: 'init',
      statusData: {
        isMissingRequiredField: true,
        maxSlippage: config.maxSlippage
      }
    }),
    _useLifecycleStatus2 = _slicedToArray(_useLifecycleStatus, 2),
    lifecycleStatus = _useLifecycleStatus2[0],
    updateLifecycleStatus = _useLifecycleStatus2[1]; // Component lifecycle
  const _useState3 = useState(''),
    _useState4 = _slicedToArray(_useState3, 2),
    transactionHash = _useState4[0],
    setTransactionHash = _useState4[1];
  const _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    hasHandledSuccess = _useState6[0],
    setHasHandledSuccess = _useState6[1];
  const _useBuyTokens = useBuyTokens(toToken, fromToken, address),
    from = _useBuyTokens.from,
    fromETH = _useBuyTokens.fromETH,
    fromUSDC = _useBuyTokens.fromUSDC,
    to = _useBuyTokens.to;
  const _useSendTransaction = useSendTransaction(),
    sendTransactionAsync = _useSendTransaction.sendTransactionAsync; // Sending the transaction (and approval, if applicable)
  const _useSendCalls = useSendCalls(),
    sendCallsAsync = _useSendCalls.sendCallsAsync; // Atomic Batch transactions (and approval, if applicable)
  // Refreshes balances and inputs post-swap
  const resetInputs = useResetBuyInputs({
    fromETH,
    fromUSDC,
    from,
    to
  });
  // For batched transactions, listens to and awaits calls from the Wallet server
  const awaitCallsStatus = useAwaitCalls({
    accountConfig,
    lifecycleStatus,
    updateLifecycleStatus
  });
  const _useOnrampEventListen = useOnrampEventListeners({
      updateLifecycleStatus,
      maxSlippage: config.maxSlippage,
      lifecycleStatus
    }),
    onPopupClose = _useOnrampEventListen.onPopupClose;
  // used to detect when the popup is closed in order to stop loading state
  const _usePopupMonitor = usePopupMonitor(onPopupClose),
    startPopupMonitor = _usePopupMonitor.startPopupMonitor;
  // Analytics
  const _useAnalytics = useAnalytics(),
    sendAnalytics = _useAnalytics.sendAnalytics;
  // Component lifecycle emitters
  useEffect(() => {
    // Error
    if (lifecycleStatus.statusName === 'error') {
      onError?.(lifecycleStatus.statusData);
    }
    // Success
    if (lifecycleStatus.statusName === 'success') {
      onSuccess?.(lifecycleStatus?.statusData.transactionReceipt);
      const txHash = lifecycleStatus.statusData.transactionReceipt?.transactionHash;
      setTransactionHash(txHash);
      setHasHandledSuccess(true);
      sendAnalytics(BuyEvent.BuySuccess, {
        address,
        amount: Number(from?.amount),
        from: from?.token?.address,
        paymaster: !!paymaster,
        to: to?.token?.address,
        transactionHash: txHash
      });
    }
    // Emit Status
    onStatus?.(lifecycleStatus);
  }, [onError, onStatus, onSuccess, lifecycleStatus, lifecycleStatus.statusData,
  // Keep statusData, so that the effect runs when it changes
  lifecycleStatus.statusName,
  // Keep statusName, so that the effect runs when it changes
  from, to, address, paymaster, sendAnalytics]);
  useEffect(() => {
    if (!projectId) {
      console.error('Project ID is required for this component, please set the projectId in the OnchainKitProvider');
    }
  }, [projectId]);
  useEffect(() => {
    // Reset inputs after status reset. `resetInputs` is dependent
    // on 'from' and 'to' so moved to separate useEffect to
    // prevents multiple calls to `onStatus`
    if (lifecycleStatus.statusName === 'init' && hasHandledSuccess) {
      setHasHandledSuccess(false);
      resetInputs();
    }
  }, [hasHandledSuccess, lifecycleStatus.statusName, resetInputs]);
  useEffect(() => {
    // For batched transactions, `transactionApproved` will contain the calls ID
    // We'll use the `useAwaitCalls` hook to listen to the call status from the wallet server
    // This will update the lifecycle status to `success` once the calls are confirmed
    if (lifecycleStatus.statusName === 'transactionApproved' && lifecycleStatus.statusData.transactionType === 'Batched') {
      awaitCallsStatus();
    }
  }, [awaitCallsStatus, lifecycleStatus, lifecycleStatus.statusData, lifecycleStatus.statusName]);
  useEffect(() => {
    let timer;
    // Reset status to init after success has been handled
    if (lifecycleStatus.statusName === 'success' && hasHandledSuccess) {
      timer = setTimeout(() => {
        updateLifecycleStatus({
          statusName: 'init',
          statusData: {
            isMissingRequiredField: true,
            maxSlippage: config.maxSlippage
          }
        });
      }, 3000);
    }
    return () => {
      if (timer) {
        return clearTimeout(timer);
      }
    };
  }, [config.maxSlippage, hasHandledSuccess, lifecycleStatus.statusName, updateLifecycleStatus]);
  const handleAmountChange = useCallback(async amount => {
    if (to.token === undefined || fromETH.token === undefined || fromUSDC.token === undefined) {
      updateLifecycleStatus({
        statusName: 'amountChange',
        statusData: {
          amountETH: fromETH.amount,
          amountUSDC: fromUSDC.amount,
          amountTo: to.amount,
          tokenTo: to.token,
          isMissingRequiredField: true
        }
      });
      return;
    }
    if (amount === '' || amount === '.' || Number.parseFloat(amount) === 0) {
      to.setAmount('');
      to.setAmountUSD('');
      fromETH.setAmountUSD('');
      fromUSDC.setAmountUSD('');
      from?.setAmountUSD('');
      return;
    }
    fromETH.setLoading(true);
    fromUSDC.setLoading(true);
    from?.setLoading(true);
    updateLifecycleStatus({
      statusName: 'amountChange',
      statusData: {
        // when fetching quote, the previous
        // amount is irrelevant
        amountTo: amount,
        amountETH: '',
        amountUSDC: '',
        amountFrom: '',
        tokenFromETH: fromETH.token,
        tokenFromUSDC: fromUSDC.token,
        tokenFrom: from?.token,
        tokenTo: to.token,
        // when fetching quote, the destination
        // amount is missing
        isMissingRequiredField: true
      }
    });
    try {
      const maxSlippage = lifecycleStatus.statusData.maxSlippage;
      const _await$getBuyQuote = await getBuyQuote({
          amount,
          from: fromETH.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: fromETH
        }),
        responseETH = _await$getBuyQuote.response,
        formattedAmountETH = _await$getBuyQuote.formattedFromAmount;
      const _await$getBuyQuote2 = await getBuyQuote({
          amount,
          from: fromUSDC.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: fromUSDC
        }),
        responseUSDC = _await$getBuyQuote2.response,
        formattedAmountUSDC = _await$getBuyQuote2.formattedFromAmount;
      const _await$getBuyQuote3 = await getBuyQuote({
          amount,
          from: from?.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: from
        }),
        responseFrom = _await$getBuyQuote3.response,
        formattedAmountFrom = _await$getBuyQuote3.formattedFromAmount;
      const _validateQuote = validateQuote({
          to,
          responseETH,
          responseUSDC,
          responseFrom,
          updateLifecycleStatus
        }),
        isValid = _validateQuote.isValid;
      if (!isValid) {
        return;
      }
      updateLifecycleStatus({
        statusName: 'amountChange',
        statusData: {
          amountETH: formattedAmountETH,
          amountUSDC: formattedAmountUSDC,
          amountFrom: formattedAmountFrom || '',
          amountTo: amount,
          tokenFromETH: fromETH.token,
          tokenFromUSDC: fromUSDC.token,
          tokenFrom: from?.token,
          tokenTo: to.token,
          // if quote was fetched successfully, we
          // have all required fields
          isMissingRequiredField: !formattedAmountETH
        }
      });
    } catch (err) {
      sendAnalytics(BuyEvent.BuyFailure, {
        error: err instanceof Error ? err.message : String(err),
        metadata: {
          amount
        }
      });
      updateLifecycleStatus({
        statusName: 'error',
        statusData: {
          code: 'TmBPc02',
          // Transaction module BuyProvider component 01 error
          error: JSON.stringify(err),
          message: ''
        }
      });
    } finally {
      // reset loading state when quote request resolves
      fromETH.setLoading(false);
      fromUSDC.setLoading(false);
      from?.setLoading(false);
    }
  }, [to, from, fromETH, fromUSDC, useAggregator, updateLifecycleStatus, lifecycleStatus.statusData.maxSlippage, sendAnalytics]);
  const handleSubmit = useCallback(async from => {
    if (!address || !from.token || !to.token || !from.amount) {
      return;
    }
    try {
      sendAnalytics(BuyEvent.BuyInitiated, {
        amount: Number(from.amount),
        token: from.token.symbol
      });
      const maxSlippage = lifecycleStatus.statusData.maxSlippage;
      const response = await buildSwapTransaction({
        amount: from.amount,
        fromAddress: address,
        from: from.token,
        maxSlippage: String(maxSlippage),
        to: to.token,
        useAggregator
      }, RequestContext.Buy);
      if (isSwapError(response)) {
        updateLifecycleStatus({
          statusName: 'error',
          statusData: {
            code: response.code,
            error: response.error,
            message: response.message
          }
        });
        return;
      }
      await processSwapTransaction({
        chainId,
        config: accountConfig,
        isSponsored,
        paymaster: paymaster || '',
        sendCallsAsync,
        sendTransactionAsync,
        swapTransaction: response,
        switchChainAsync,
        updateLifecycleStatus,
        useAggregator,
        walletCapabilities
      });
    } catch (err) {
      sendAnalytics(BuyEvent.BuyFailure, {
        error: err instanceof Error ? err.message : String(err),
        metadata: {
          token: from.token.symbol,
          amount: from.amount
        }
      });
      const errorMessage = isUserRejectedRequestError(err) ? 'Request denied.' : GENERIC_ERROR_MESSAGE;
      updateLifecycleStatus({
        statusName: 'error',
        statusData: {
          code: 'TmBPc03',
          error: JSON.stringify(err),
          message: errorMessage
        }
      });
    }
  }, [accountConfig, address, chainId, isSponsored, lifecycleStatus, paymaster, sendCallsAsync, sendTransactionAsync, switchChainAsync, to.token, updateLifecycleStatus, useAggregator, walletCapabilities, sendAnalytics]);
  const value = useValue({
    address,
    config,
    disabled,
    from,
    fromETH,
    fromUSDC,
    handleAmountChange,
    handleSubmit,
    lifecycleStatus,
    updateLifecycleStatus,
    to,
    setTransactionHash,
    transactionHash,
    isDropdownOpen,
    setIsDropdownOpen,
    toToken,
    fromToken,
    startPopupMonitor
  });
  return /*#__PURE__*/jsx(BuyContext.Provider, {
    value: value,
    children: children
  });
}
export { BuyContext, BuyProvider, useBuyContext };
//# sourceMappingURL=BuyProvider.js.map
