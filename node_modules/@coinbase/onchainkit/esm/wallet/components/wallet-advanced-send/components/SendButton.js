'use client';
import { Transaction } from '../../../../transaction/components/Transaction.js';
import { TransactionButton } from '../../../../transaction/components/TransactionButton.js';
import { useTransactionContext } from '../../../../transaction/components/TransactionProvider.js';
import { TransactionStatus } from '../../../../transaction/components/TransactionStatus.js';
import { TransactionStatusAction } from '../../../../transaction/components/TransactionStatusAction.js';
import { TransactionStatusLabel } from '../../../../transaction/components/TransactionStatusLabel.js';
import { useCallback } from 'react';
import { parseUnits } from 'viem';
import { base } from 'viem/chains';
import { useWalletContext } from '../../WalletProvider.js';
import { defaultSendTxSuccessHandler } from '../utils/defaultSendTxSuccessHandler.js';
import { getSendCalldata } from '../utils/getSendCalldata.js';
import { useSendContext } from './SendProvider.js';
import { jsxs, jsx } from 'react/jsx-runtime';
function SendButton({
  label,
  isSponsored = false,
  className,
  disabled,
  pendingOverride,
  successOverride,
  errorOverride
}) {
  const _useWalletContext = useWalletContext(),
    senderChain = _useWalletContext.chain;
  const _useSendContext = useSendContext(),
    selectedRecipient = _useSendContext.selectedRecipient,
    inputAmount = _useSendContext.cryptoAmount,
    selectedToken = _useSendContext.selectedToken,
    updateLifecycleStatus = _useSendContext.updateLifecycleStatus;
  const _getSendCalldata = getSendCalldata({
      recipientAddress: selectedRecipient.address,
      token: selectedToken,
      amount: inputAmount
    }),
    calldata = _getSendCalldata.calldata,
    error = _getSendCalldata.error;
  const disableSendButton = disabled || Boolean(error) || !validateAmountInput({
    inputAmount: inputAmount ?? '',
    balance: BigInt(selectedToken?.cryptoBalance ?? 0),
    selectedToken: selectedToken ?? undefined
  });
  const buttonLabel = label ?? getDefaultSendButtonLabel(inputAmount, selectedToken);
  const handleStatus = useCallback(status => {
    const validStatuses = ['transactionPending', 'transactionLegacyExecuted', 'success', 'error'];
    if (validStatuses.includes(status.statusName)) {
      updateLifecycleStatus(status);
    }
  }, [updateLifecycleStatus]);
  return /*#__PURE__*/jsxs(Transaction, {
    isSponsored: isSponsored,
    chainId: senderChain?.id ?? base.id,
    calls: calldata ? [calldata] : [],
    onStatus: handleStatus,
    children: [/*#__PURE__*/jsx(SendTransactionButton, {
      label: buttonLabel,
      senderChain: senderChain,
      pendingOverride: pendingOverride,
      errorOverride: errorOverride,
      successOverride: successOverride,
      disabled: disableSendButton,
      className: className
    }), /*#__PURE__*/jsxs(TransactionStatus, {
      children: [/*#__PURE__*/jsx(TransactionStatusLabel, {}), /*#__PURE__*/jsx(TransactionStatusAction, {})]
    })]
  });
}
/**
 * SendTransactionButton required to be a nested component in order to pull from TransactionContext.
 * Need to pull from TransactionContext in order to get transactionHash and transactionId.
 * Need transactionHash and transactionId in order to determine where to open the transaction in the wallet or explorer.
 */
function SendTransactionButton({
  label,
  senderChain,
  disabled,
  pendingOverride,
  successOverride,
  errorOverride,
  className
}) {
  const _useWalletContext2 = useWalletContext(),
    address = _useWalletContext2.address,
    setActiveFeature = _useWalletContext2.setActiveFeature;
  const _useTransactionContex = useTransactionContext(),
    transactionHash = _useTransactionContex.transactionHash,
    transactionId = _useTransactionContex.transactionId;
  const completionHandler = useCallback(() => {
    setActiveFeature(null);
  }, [setActiveFeature]);
  const defaultSuccessOverride = {
    onClick: defaultSendTxSuccessHandler({
      transactionId,
      transactionHash,
      senderChain: senderChain ?? undefined,
      address: address ?? undefined,
      onComplete: completionHandler
    })
  };
  return /*#__PURE__*/jsx(TransactionButton, {
    className: className,
    text: label,
    pendingOverride: pendingOverride,
    successOverride: successOverride ?? defaultSuccessOverride,
    errorOverride: errorOverride,
    disabled: disabled
  });
}
function getDefaultSendButtonLabel(cryptoAmount, selectedToken) {
  if (!cryptoAmount) {
    return 'Input amount';
  }
  if (!selectedToken) {
    return 'Select token';
  }
  if (parseUnits(cryptoAmount, selectedToken.decimals) > selectedToken.cryptoBalance) {
    return 'Insufficient balance';
  }
  return 'Continue';
}
function validateAmountInput({
  inputAmount,
  balance,
  selectedToken
}) {
  if (!inputAmount || !selectedToken || !balance) {
    return false;
  }
  const parsedCryptoAmount = parseUnits(inputAmount, selectedToken.decimals);
  return parsedCryptoAmount > 0n && parsedCryptoAmount <= balance;
}
export { SendButton };
//# sourceMappingURL=SendButton.js.map
