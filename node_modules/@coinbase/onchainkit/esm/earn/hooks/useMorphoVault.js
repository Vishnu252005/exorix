'use client';
import { MORPHO_VAULT_ABI } from '../abis/morpho.js';
import { MORPHO_TOKEN_BASE_ADDRESS } from '../constants.js';
import calculateMorphoRewards from '../utils/calculateMorphoRewards.js';
import { fetchMorphoApy } from '../utils/fetchMorphoApy.js';
import { useQuery } from '@tanstack/react-query';
import { formatUnits } from 'viem';
import { base } from 'viem/chains';
import { useReadContracts, useReadContract } from 'wagmi';
// eslint-disable-next-line complexity
function useMorphoVault({
  vaultAddress,
  recipientAddress
}) {
  const _useReadContracts = useReadContracts({
      contracts: [{
        abi: MORPHO_VAULT_ABI,
        address: vaultAddress,
        functionName: 'asset',
        chainId: base.id // Only Base is supported
      }, {
        abi: MORPHO_VAULT_ABI,
        address: vaultAddress,
        functionName: 'name',
        chainId: base.id // Only Base is supported
      }, {
        abi: MORPHO_VAULT_ABI,
        address: vaultAddress,
        functionName: 'decimals',
        chainId: base.id // Only Base is supported
      }],
      query: {
        enabled: !!vaultAddress
      }
    }),
    data = _useReadContracts.data,
    status = _useReadContracts.status;
  const assetAddress = data?.[0].result;
  const vaultName = data?.[1].result;
  const vaultDecimals = data?.[2].result;
  // Fetching separately because user may not be connected
  const _useReadContract = useReadContract({
      abi: MORPHO_VAULT_ABI,
      address: vaultAddress,
      functionName: 'maxWithdraw',
      args: [recipientAddress],
      chainId: base.id,
      // Only Base is supported
      query: {
        enabled: !!vaultAddress && !!recipientAddress
      }
    }),
    balance = _useReadContract.data,
    balanceStatus = _useReadContract.status,
    refetch = _useReadContract.refetch;
  const _useQuery = useQuery({
      queryKey: ['morpho-apy', vaultAddress],
      queryFn: () => fetchMorphoApy(vaultAddress)
    }),
    vaultData = _useQuery.data,
    error = _useQuery.error;
  const morphoApr = vaultData?.state ? calculateMorphoRewards(vaultData?.state) : 0;
  const formattedBalance = balance && vaultData?.asset.decimals ? formatUnits(balance, vaultData?.asset.decimals) : undefined;
  const formattedDeposits = vaultData?.state.totalAssets && vaultData.asset.decimals ? formatUnits(BigInt(vaultData?.state.totalAssets), vaultData.asset.decimals) : undefined;
  const formattedLiquidity = vaultData?.liquidity.underlying && vaultData.asset.decimals ? formatUnits(BigInt(vaultData?.liquidity.underlying), vaultData.asset.decimals) : undefined;
  return {
    status,
    error,
    /** Balance is the amount of the underlying asset that the user has in the vault */
    balance: formattedBalance,
    balanceStatus,
    refetchBalance: refetch,
    asset: {
      address: assetAddress,
      symbol: vaultData?.symbol,
      decimals: vaultData?.asset.decimals
    },
    vaultName,
    vaultDecimals,
    totalApy: vaultData?.state?.netApy,
    nativeApy: vaultData?.state?.netApyWithoutRewards,
    vaultFee: vaultData?.state?.fee,
    deposits: formattedDeposits,
    liquidity: formattedLiquidity,
    rewards: [{
      asset: MORPHO_TOKEN_BASE_ADDRESS,
      assetName: 'MORPHO',
      apy: morphoApr
    }, ...(vaultData?.state?.rewards.map(reward => ({
      asset: reward.asset.address,
      assetName: reward.asset.name,
      apy: reward.supplyApr
    })) || [])]
  };
}
export { useMorphoVault };
//# sourceMappingURL=useMorphoVault.js.map
