function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
import sdk from '@farcaster/frame-sdk';
import { useCallback } from 'react';
import { useMiniKit } from './useMiniKit.js';

/**
 * Parse the sign in message
 * @param message - The sign in message to parse
 * @returns {ParsedSignInMessage} - The parsed sign in message
 */
function parseSignInMessage(message) {
  const _message$split = message.split('\n'),
    _message$split2 = _toArray(_message$split),
    domainLine = _message$split2[0],
    address = _message$split2[1],
    rest = _message$split2.slice(2);
  const _domainLine$split = domainLine.split(' wants you to sign in with your Ethereum account:'),
    _domainLine$split2 = _slicedToArray(_domainLine$split, 1),
    domain = _domainLine$split2[0];
  const parsedData = {
    domain,
    address,
    chainID: '',
    issuedAt: '',
    nonce: '',
    resources: [],
    uri: '',
    version: ''
  };
  return rest.reduce((acc, line) => {
    if (line.includes(': ')) {
      const _line$split = line.split(': '),
        _line$split2 = _slicedToArray(_line$split, 2),
        key = _line$split2[0],
        value = _line$split2[1];
      const camelKey = key.replace(/^([^\s]+)(?:\s+)?/, (_, firstWord) => firstWord.toLowerCase());
      acc[camelKey] = value;
      return acc;
    }
    if (line.startsWith('- ')) {
      acc.resources.push(line.slice(2));
      return acc;
    }
    return acc;
  }, parsedData);
}
/**
 * Validate the sign in message
 * @param message - The sign in message to validate
 * @param domain [optional] - The domain of the frame to validate against, if not provided, the domain will not be validated
 * @param fid [optional] - The fid of the frame to validate against, if not provided, the fid will not be validated
 * @param nonce [optional] - The nonce to validate against, if not provided, the nonce will not be validated
 * @returns void
 */
function validateSignInMessage({
  message,
  domain,
  fid,
  nonce
}) {
  const parsed = parseSignInMessage(message);
  if (domain) {
    const domainUrlObj = new URL(domain);

    // domain in message should match frame's domain
    if (domainUrlObj.hostname !== parsed.domain) {
      throw new Error('Domain mismatch');
    }
  }

  // validate nonce
  if (nonce && parsed.nonce !== nonce) {
    throw new Error('Nonce mismatch');
  }

  // validate fid
  if (fid) {
    const fidRegex = new RegExp(`^farcaster://fid/${fid}$`);
    const fidMatch = parsed.resources.find(resource => fidRegex.test(resource));
    if (!fidMatch) {
      throw new Error('Fid mismatch');
    }
  }
}
/**
 * Authenticates the user's account.
 * @param domain [optional] - The domain of the frame to authenticate against, if not provided, the domain will not be validated
 * @returns `signIn` - A function that wraps the frames SDK signIn action and returns the result of the signIn action
 * by default validates the nonce and fid
 */
const useAuthenticate = domain => {
  const _useMiniKit = useMiniKit(),
    context = _useMiniKit.context;
  const signIn = useCallback(async (signInOptions = {}) => {
    try {
      if (!signInOptions?.nonce) {
        signInOptions.nonce = [...Array(8)].map(() => Math.floor(Math.random() * 36).toString(36)).join('');
      }
      const result = await sdk.actions.signIn(signInOptions);
      validateSignInMessage({
        message: result.message,
        domain,
        fid: context?.client.clientFid,
        nonce: signInOptions.nonce
      });
      return result;
    } catch (error) {
      console.error(error);
      return false;
    }
  }, [domain, context?.client.clientFid]);
  return {
    signIn
  };
};
export { parseSignInMessage, useAuthenticate };
//# sourceMappingURL=useAuthenticate.js.map
