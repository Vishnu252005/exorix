'use client';
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
import { isApplePaySupported } from '../../buy/utils/isApplePaySupported.js';
import { Skeleton } from '../../internal/components/Skeleton.js';
import { useOutsideClick } from '../../internal/hooks/useOutsideClick.js';
import { formatFiatAmount } from '../../internal/utils/formatFiatAmount.js';
import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { useAnalytics } from '../../core/analytics/hooks/useAnalytics.js';
import { FundEvent } from '../../core/analytics/types.js';
import { cn, background, border } from '../../styles/theme.js';
import { FundCardPaymentMethodSelectRow } from './FundCardPaymentMethodSelectRow.js';
import { FundCardPaymentMethodSelectorToggle } from './FundCardPaymentMethodSelectorToggle.js';
import { useFundContext } from './FundCardProvider.js';
import { jsxs, jsx } from 'react/jsx-runtime';
function FundCardPaymentMethodDropdown({
  className
}) {
  const _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isOpen = _useState2[0],
    setIsOpen = _useState2[1];
  const _useFundContext = useFundContext(),
    selectedPaymentMethod = _useFundContext.selectedPaymentMethod,
    setSelectedPaymentMethod = _useFundContext.setSelectedPaymentMethod,
    paymentMethods = _useFundContext.paymentMethods,
    fundAmountFiat = _useFundContext.fundAmountFiat,
    isPaymentMethodsLoading = _useFundContext.isPaymentMethodsLoading,
    currency = _useFundContext.currency;
  const _useAnalytics = useAnalytics(),
    sendAnalytics = _useAnalytics.sendAnalytics;
  const filteredPaymentMethods = useMemo(() => {
    return paymentMethods.filter(method => method.id !== 'APPLE_PAY' || isApplePaySupported());
  }, [paymentMethods]);
  const getPaymentMethodDisabledReason = useCallback(method => {
    const amount = Number(fundAmountFiat);
    if (method.minAmount && amount < method.minAmount) {
      return `Minimum amount of ${formatFiatAmount({
        amount: method.minAmount,
        currency: currency,
        minimumFractionDigits: 0
      })} required`;
    }
    if (method.maxAmount && amount > method.maxAmount) {
      return `Maximum amount allowed is ${formatFiatAmount({
        amount: method.maxAmount,
        currency: currency,
        minimumFractionDigits: 0
      })}`;
    }
    return undefined;
  }, [fundAmountFiat, currency]);
  const isPaymentMethodDisabled = useCallback(method => {
    if (!fundAmountFiat) {
      return false;
    }
    return Boolean(getPaymentMethodDisabledReason(method));
  }, [fundAmountFiat, getPaymentMethodDisabledReason]);
  // If current selected method becomes disabled, switch to Coinbase
  useEffect(() => {
    if (selectedPaymentMethod && isPaymentMethodDisabled(selectedPaymentMethod)) {
      const coinbaseMethod = paymentMethods.find(m => m.id === '');
      if (coinbaseMethod) {
        setSelectedPaymentMethod(coinbaseMethod);
      }
    }
  }, [selectedPaymentMethod, paymentMethods, setSelectedPaymentMethod, isPaymentMethodDisabled]);
  const handlePaymentMethodSelect = useCallback(paymentMethod => {
    if (!isPaymentMethodDisabled(paymentMethod)) {
      sendAnalytics(FundEvent.FundOptionSelected, {
        option: paymentMethod.id
      });
      setSelectedPaymentMethod(paymentMethod);
      setIsOpen(false);
    }
  }, [setSelectedPaymentMethod, isPaymentMethodDisabled, sendAnalytics]);
  const handleToggle = useCallback(() => {
    setIsOpen(!isOpen);
  }, [isOpen]);
  const dropdownRef = useRef(null);
  const dropdownContainerRef = useRef(null);
  const buttonRef = useRef(null);
  useOutsideClick(dropdownContainerRef, () => {
    if (isOpen) {
      setIsOpen(false);
    }
  });
  const handleEscKeyPress = useCallback(event => {
    if (event.key === 'Escape') {
      setIsOpen(false);
    }
  }, []);
  const paymentMethod = selectedPaymentMethod || filteredPaymentMethods[0];
  return /*#__PURE__*/jsxs("div", {
    className: cn('relative py-4', className),
    ref: dropdownContainerRef,
    "data-testid": "ockFundCardPaymentMethodDropdownContainer",
    onKeyUp: handleEscKeyPress,
    children: [isPaymentMethodsLoading || !paymentMethod ? /*#__PURE__*/jsx(Skeleton, {
      className: "h-12 w-full"
    }) : /*#__PURE__*/jsx(FundCardPaymentMethodSelectorToggle, {
      ref: buttonRef,
      onClick: handleToggle,
      isOpen: isOpen,
      paymentMethod: paymentMethod
    }), isOpen && /*#__PURE__*/jsx("div", {
      ref: dropdownRef,
      "data-testid": "ockFundCardPaymentMethodDropdown",
      className: cn(border.radius, border.lineDefault, 'ock-scrollbar absolute z-10 mt-2 flex w-full flex-col overflow-y-hidden'),
      children: /*#__PURE__*/jsx("div", {
        className: cn(background.default, 'overflow-y-auto p-2'),
        children: filteredPaymentMethods.map(paymentMethod => {
          const isDisabled = isPaymentMethodDisabled(paymentMethod);
          return /*#__PURE__*/jsx(FundCardPaymentMethodSelectRow, {
            testId: `ockFundCardPaymentMethodSelectRow__${paymentMethod.id}`,
            paymentMethod: paymentMethod,
            onClick: handlePaymentMethodSelect,
            disabled: isDisabled,
            disabledReason: getPaymentMethodDisabledReason(paymentMethod)
          }, paymentMethod.name);
        })
      })
    })]
  });
}
export { FundCardPaymentMethodDropdown };
//# sourceMappingURL=FundCardPaymentMethodDropdown.js.map
