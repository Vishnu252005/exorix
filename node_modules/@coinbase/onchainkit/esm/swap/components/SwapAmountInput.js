'use client';
import { useEffect, useCallback, useMemo } from 'react';
import { useAnalytics } from '../../core/analytics/hooks/useAnalytics.js';
import { SwapEvent } from '../../core/analytics/types.js';
import { TextInput } from '../../internal/components/TextInput.js';
import { useValue } from '../../internal/hooks/useValue.js';
import { getRoundedAmount } from '../../internal/utils/getRoundedAmount.js';
import { isValidAmount } from '../../internal/utils/isValidAmount.js';
import { cn, text, color, pressable, background, border } from '../../styles/theme.js';
import '../../token/index.js';
import { formatAmount } from '../utils/formatAmount.js';
import { useSwapContext } from './SwapProvider.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { TokenSelectDropdown } from '../../token/components/TokenSelectDropdown.js';
import { TokenChip } from '../../token/components/TokenChip.js';
function SwapAmountInput({
  className,
  delayMs = 1000,
  label,
  token,
  type,
  swappableTokens
}) {
  const _useSwapContext = useSwapContext(),
    address = _useSwapContext.address,
    to = _useSwapContext.to,
    from = _useSwapContext.from,
    handleAmountChange = _useSwapContext.handleAmountChange;
  const _useAnalytics = useAnalytics(),
    sendAnalytics = _useAnalytics.sendAnalytics;
  const source = useValue(type === 'from' ? from : to);
  const destination = useValue(type === 'from' ? to : from);
  const setToken = source.setToken,
    setAmount = source.setAmount,
    balance = source.balance,
    amount = source.amount,
    amountUSD = source.amountUSD;
  useEffect(() => {
    if (token) {
      setToken?.(token);
    }
  }, [token, setToken]);
  const handleMaxButtonClick = useCallback(() => {
    if (!balance) {
      return;
    }
    setAmount(balance);
    handleAmountChange(type, balance);
  }, [balance, setAmount, handleAmountChange, type]);
  const handleChange = useCallback(amount => {
    handleAmountChange(type, amount);
  }, [handleAmountChange, type]);
  const handleAnalyticsTokenSelected = useCallback(token => {
    sendAnalytics(SwapEvent.TokenSelected, {
      token: token.symbol
    });
  }, [sendAnalytics]);
  const handleSetToken = useCallback(token => {
    setToken?.(token);
    handleAmountChange(type, amount, token);
    handleAnalyticsTokenSelected(token);
  }, [amount, setToken, handleAmountChange, handleAnalyticsTokenSelected, type]);
  // We are mocking the token selectors so I'm not able
  // to test this since the components aren't actually rendering
  const sourceTokenOptions = useMemo(() => {
    return swappableTokens?.filter(({
      symbol
    }) => symbol !== destination.token?.symbol) ?? [];
  }, [swappableTokens, destination.token]);
  const hasInsufficientBalance = type === 'from' && Number(balance) < Number(amount);
  const formatUSD = amount => {
    if (!amount || amount === '0') {
      return null;
    }
    const roundedAmount = Number(getRoundedAmount(amount, 2));
    return `~$${roundedAmount.toFixed(2)}`;
  };
  return /*#__PURE__*/jsxs("div", {
    className: cn(background.secondary, border.radius, 'my-0.5 box-border flex h-[148px] w-full flex-col items-start p-4', className),
    "data-testid": "ockSwapAmountInput_Container",
    children: [/*#__PURE__*/jsx("div", {
      className: cn(text.label2, color.foregroundMuted, 'flex w-full items-center justify-between'),
      children: label
    }), /*#__PURE__*/jsxs("div", {
      className: "flex w-full items-center justify-between",
      children: [/*#__PURE__*/jsx(TextInput, {
        className: cn('mr-2 w-full border-[none] bg-transparent font-display text-[2.5rem]', 'leading-none outline-none', hasInsufficientBalance && address ? color.error : color.foreground),
        placeholder: "0.0",
        delayMs: delayMs,
        value: formatAmount(amount),
        setValue: setAmount,
        disabled: source.loading,
        onChange: handleChange,
        inputValidator: isValidAmount
      }), sourceTokenOptions.length > 0 ? /*#__PURE__*/jsx(TokenSelectDropdown, {
        token: source.token,
        setToken: handleSetToken,
        options: sourceTokenOptions
      }) : source.token && /*#__PURE__*/jsx(TokenChip, {
        className: pressable.inverse,
        token: source.token
      })]
    }), /*#__PURE__*/jsxs("div", {
      className: "mt-4 flex w-full items-center justify-between",
      children: [/*#__PURE__*/jsx("div", {
        className: cn(text.label2, color.foregroundMuted),
        children: formatUSD(amountUSD)
      }), /*#__PURE__*/jsxs("div", {
        className: cn(text.label2, color.foregroundMuted, 'flex grow items-center justify-end'),
        children: [balance && /*#__PURE__*/jsx("span", {
          children: `Balance: ${getRoundedAmount(balance, 8)}`
        }), type === 'from' && address && /*#__PURE__*/jsx("button", {
          type: "button",
          className: cn(text.label1, color.primary, 'flex cursor-pointer items-center justify-center px-2 py-1'),
          "data-testid": "ockSwapAmountInput_MaxButton",
          onClick: handleMaxButtonClick,
          children: "Max"
        })]
      })]
    })]
  });
}
export { SwapAmountInput };
//# sourceMappingURL=SwapAmountInput.js.map
